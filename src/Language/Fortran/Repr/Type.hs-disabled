{-

-- | Recover the most appropriate 'TypeSpec' for the given 'Ty', depending on
--   the given 'FortranVersion'.
--
-- Kinds weren't formalized as a syntactic feature until Fortran 90, so we ask
-- for a context. If possible (>=F90), we prefer the more explicit
-- representation e.g. @REAL(8)@. For older versions, for specific type-kind
-- combinations, @DOUBLE PRECISION@ and @DOUBLE COMPLEX@ are used instead.
-- However, we otherwise don't shy away from adding kind info regardless of
-- theoretical version support.
--
-- This is a "best effort": 'TypeSpec' is a highly syntactic representation and
-- doesn't store array type information. Perhaps better would be to recover a
-- full 'StDeclaration'.
recoverTyTypeSpec
    :: forall a. a -> SrcSpan -> FortranVersion -> Ty -> TypeSpec a
recoverTyTypeSpec a ss v = \case
  TyArrayTy  aTy -> -- nowhere to put array info, so only recover scalar info
    recoverScalarTyTypeSpec (aTyScalar aTy)
  TyScalarTy sTy -> recoverScalarTyTypeSpec sTy
  where
    recoverScalarTyTypeSpec = \case
      ScalarTyIntrinsic iTy -> recoverIntrinsicTyTypeSpec iTy
      ScalarTyCustom ty' -> ts (TypeCustom ty') Nothing
    recoverIntrinsicTyTypeSpec (IntrinsicTy bTy k) =
        case bTy of
          BTyInteger -> buildTs (Just (k, 4)) TypeInteger Nothing
          BTyLogical -> buildTs (Just (k, 4)) TypeLogical Nothing
          BTyReal    ->
            if   v < Fortran90 && k == 8
            then buildTs Nothing TypeDoublePrecision Nothing
            else buildTs (Just (k, 4)) TypeReal Nothing
          BTyComplex ->
            if   v < Fortran90 && k == 16
            then buildTs Nothing TypeDoubleComplex Nothing
            else buildTs (Just (k, 8)) TypeComplex Nothing
          BTyCharacter len ->
            case len of
              CharLen len' ->
                if   len' == 1
                then buildTs (Just (k, 1)) TypeCharacter Nothing
                else buildTs (Just (k, 1)) TypeCharacter (Just (intValExpr len'))
              CharLenAssumed  -> buildTs (Just (k, 1)) TypeCharacter (Just valStarExpr)
              CharLenDeferred -> buildTs (Just (k, 1)) TypeCharacter (Just valColonExpr)
    -- don't get why I need the function signature down here... GHC infers it
    -- correctly (via @:: _@) but I get an Eq a0 complaint??? assuming scoped
    -- typevar weirdness...
    buildTs :: Maybe (Int, Int) -> BaseType -> Maybe (Expression a) -> TypeSpec a
    buildTs (Just (k, kDef)) ty mLen =
        if   k == kDef
        then buildTs Nothing ty mLen
        else ts ty (Just (sel mLen (Just (intValExpr k))))
    buildTs Nothing ty (Just len) = ts ty (Just (sel (Just len) Nothing))
    buildTs Nothing ty Nothing = ts ty Nothing
    intValExpr x = valExpr (ValInteger (show x))
    valStarExpr  = valExpr ValStar
    valColonExpr = valExpr ValStar
    valExpr = ExpValue a ss
    ts  = TypeSpec a ss
    sel = Selector a ss

-}
